# 数据结构绪论



数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。

## 基本概念和术语

### 数据

概念：数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并**输入给计算机处理**的符号集合。

数据=符号，但是需具备两个前提：可以输入到计算机中；能被计算机处理。

类型：数值类型（整型、实型等）【可计算数值】、非数值类型（字符、声音、图像、视频等）【通过编码的手段变成字符数据】。

### 数据元素

概念：数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也称为记录。

数据元素是数据结构中建立数据模型的着眼点。

### 数据项

概念：一个数据元素可以由若干数据项组成。数据项是数据不可分割的最小单位。

### 数据对象

概念：数据对象是性质相同的数据元素的集合，是数据的子集。

### 数据结构

数据元素存在特定关系。这种关系称为结构。

概念：数据结构是相互之间存在一种或多种和特定关系的数据元素的集合。



## 逻辑结构与物理结构

### 逻辑结构

概念：数据对象中数据元素之间的相互关系。

#### 集合结构

类似于数学中的集合，同属于一个集合，数据元素之间是平等的。

#### 线性结构

一对一，连成一条线。

#### 树形结构

一对多的层次关系

#### 图形结构

多对多的关系，像关系网

ps.关系可能是有方向的。

### 物理结构

概念：物理结构是数据的逻辑结构在计算机中的存储形式。

也就是把数据元素存储到计算机的存储器中。同时，数据的存储结构应该正确反映数据元素之间的逻辑关系。

存储形式：顺序存储和链式存储。

#### 顺序存储结构

概念：顺序存储结构是把数据元素放在地址连续的存储单位里，其数据间逻辑关系和物理关系一致。

#### 链式存储结构

概念：链式存储结构是把数据元素存放在任意存储单元里，这组存储单元可以是连续的，也可以是不连续的。

数据元素的存储关系并不能反映其逻辑关系，需要用一个指针存放数据元素的地址。可以通过地址找到相关联数据元素的位置。



## 抽象数据类型

### 数据类型

概念：数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作总称。

数据类型是按照值得不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。

如c语言中变量声明int a, b。在给变量a和b赋值时不能超出int的取值范围，变量a和b之间的运算只能是int类型所允许的运算。

### 抽象数据类型

概念：抽象数据类型是指一个数学模型及定义在该模型上的一组操作。

抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。

可以是已定义并实现的数据类型，也可是自己定义的数据类型。

抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。

过程：问题分解成多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。



# 算法

## 算法的定义

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

为了解决某个或某类问题，需要把指令表示成一定的操作序列。操作序列包括一组操作。每个操作都完成特定的功能——算法

## 算法的特性

基本特性（5）：输入、输出、有穷性、确定性和可行性；

### 输入输出

算法输入>=0，一般情况下，输入参数是必要的；

算法输出>=1

### 有穷性

有穷性是指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成；

不是数学上的概念，而是需要有一个合理的边界；

### 确定性

确定性指算法的每一步骤都具有确定的含义，不会出现二义性；

一条执行路径（相同的输入只能有唯一的输出结果）；算法每个步骤都被精确定义而无歧义；

### 可行性

可行性指算法的每一步都必须可行，也就是说，每一步都能够通过执行有限次数完成。

可以转换为程序上机运行，并得到正确的结果。

## 算法设计的要求

### 正确性

概念：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

4个层次（从易到难）：

1. 算法程序没有语法错误；
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果；
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果；
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果；

层次4最困难，几乎不可能验证；因此，一般以3作为算法是否正确的标准；

### 可读性

概念：算法设计的另一目的是为了便于阅读、理解和交流；

### 健壮性

概念：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

### 时间效率高和存储量低

概念：

1. 时间效率：算法的执行时间
2. 存储量需求：算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间

## 算法效率的度量方法

### 事后统计方法

概念：主要通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

很大的缺陷：耗时耗力；时间的比较依赖计算机硬件和软件等环境因素；测试数据设计困难，且程序运行时间和测试数据的规模有很大关系；

基本不采纳

### 事前分析估算方法

1. 概念：在计算机程序编制前，依据统计方法对算法进行估算；

2. 决定消耗时间的因素：

1. 算法采用的策略、方法；（算法好坏根本）
2. 编译产生的代码质量；（软件）
3. 问题的输入规模；（输入量）
4. 机器执行指令的速度；（硬件性能）

主要依赖于算法好坏和问题输入规模

3. 测定运行时间最可靠的方法

计算对运行时间有消耗的基本操作的执行次数（和运行时间成正比），即将程序看作是独立于程序设计语言的算法或一系列步骤；

分析时，把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数 =》f(n) = n  f(n) = 1

主要通过算法时间复杂度来估算时间效率

## 函数的渐近增长

概念：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。

结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数；

## 算法时间复杂度

### 定义

在进行算法分析时， 语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n) 的数量级。

算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

O(1)=》常数阶   O(n)=》线性阶  O(n²) =》平方阶

### 推导大O阶方法

总结来说就是常数改成1，再取最高阶项

### 常数阶

O(1)：与问题的大小无关（即n的大小），执行时间恒定的算法

### 线性阶

O(n)

关键：分析循环结构的运行情况

### 对数阶

O(logn)

```
init count = 1;
while (count < n) {
	count = count * 2;
}
```

### 平方阶

O(n²)

主要是考察数列的相关运算

## 常见的时间复杂度

O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2的指数)<O(n!)<O(n的指数)

## 最坏情况与平均情况

最坏情况：是一种保证。除非特别指定，提到的运行时间都是最坏的运行时间。

平均情况：平均运行时间是期望是运行时间；

## 算法空间复杂度

概念：算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所存储空间的函数。

相关因素：程序本身的指令、常数、变量和输入数据、对数据操作的存储单元；

# 线性表

## 线性表的定义

线性表（List）：零个或多个数据元素的**有限**序列。

序列意味着元素之间有顺序；第一个元素无前驱，最后一个无后继，其他每个元素都有且只有一个前驱和后继。

线性表的个数n（n>=0）定义为线性表的长度，当n=0时，称为空表。

在较复杂的线性表中，一个数据元素可以由若干个数据项组成。

PS.线性表需要相同类型的数据。

## 线性表的抽象数据类型

线性表的操作：重置为空表，根据位序获取数据元素，查找元素，获取线性表长度，插入数据和删除数据；

线性表的抽象数据类型定义：

```
ADT 线性表
Data 
	线性表的数据对象集合为{a1, a2,..., an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an之外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
operation
	初始化
	判断是否为空
	线性表清空
	根据位序获取数据元素
	查找元素
	获取线性表长度
	插入数据
	删除数据
endADT
```

## 线性表的顺序存储结构

### 顺序存储定义

指的是用一段地址连续的存储单元依次存储线性表

### 顺序存储方式

类似于一维数组（将第一个数据元素存在数组下标为0的位置，再把线性表相邻的元素存储在数组中相邻的位置。

描述顺序存储结构需要三个属性：

- 存储空间的起始位置：数组data，其存储位置就是存储空间的存储位置
- 线性表的最大存储容量：数组长度MaxSize；
- 线性表的当前长度：length；

### 数据长度与线性表长度区别

数组长度：存放线性表的存储空间的长度，存储分配后这个量是不变的；

线性表长度：线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。

线性表长度<=数组长度

### 地址计算方法

下标从0开始；第i个元素下标i-1的位置；

地址：存储器中的每个存储单元的编号；

线性表中的数据元素的存储位置之间的关系：

```
LOC(a(i+1)) = LOC(a(i)) + c   第i+1个数据元素存储位置和第i个数据元素的存储位置
LOC(a(i)) = LOC(a(1)) + (i-1)*c  第i个数据元素a(i)的存储位置与a(1)之间的关系
LOC表示获得存储位置的函数
```

随机存取结构：通过上面的公式，可随时算出线性表中任意位置的地址，可任意存入或取出。存取时间性能为O(1)。

## 顺序存储结构的插入与删除

### 获得元素操作

返回对应下标的值

### 插入操作

插入算法的思路：

- 插入位置不合理，则抛出异常；
- 线性表长度>=数组长度，则抛出异常或动态增加容量；
- 从最后一个元素开始向前遍历到第i个元素，分别将它们都向后移动一个位置；
- 将要插入的元素填入位置i处；
- 表长加1；

### 删除操作

删除算法的思路：

- 删除位置不合理，则抛出异常；
- 取出删除元素；
- 从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前移动一个位置；
- 表长减1；

线性表的顺序存储结构：

在存、读数据时，时间复杂度为O(1)；在插入或删除时，时间复杂度是O(n)；

因此，适合元素个数不太变化，经常存取数据的情况。

### 线性表顺序存储结构的优缺点

优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间；可快速存取表中任一位置的元素；

缺点：插入和删除操作需要移动大量元素；当线性表长度变化较大时，难以确定存储空间的容量；造成存储空间的碎片；

## 线性表的链式存储结构

### 定义

数据元素既要存储本身信息，又要存储指示其直接后继的信息（即直接后继的存储位置）。

数据域：存储数据元素信息的域；

指针域：存储直接后继位置的域；存储的信息称作**指针**或**链**；

数据域和指针域组成数据元素ai的**存储映像**，称为**结点**。

概念：n个节点（ai的存储映像）链结成一个链表，即为线性表的链式存储结构。同时，此链表的每个节点只包含了一个指针域，所以叫单链表。

链表中的第一个节点的存储位置叫做头指针（指向第一个结点）；最后一个结点指针为空；

头节点：有时，为了方便操作，向单链表的第一个结点前附设的一个节点。可不存储任何信息；也可存储如线性表的长度等附加信息。指针域指向第一个节点的指针。

### 头指针和头结点的异同

头指针：

- 指链表指向第一个结点的指针；若链表有头结点，则是指向头结点的指针；
- 具有标识作用，因此常用头指针冠以链表的名字；
- 头指针是链表的必要元素。无论链表是否为空，头指针均不为空；

头结点：

- 为了方便而设立，放在第一元素的结点之前，其数据域一般无意义或存放链表长度；
- 第一元素结点前插入结点和删除第一结点的操作与其他结点一致；
- 不是链表必要元素；

头指针 =》头结点（空数据域+指向第一个结点的指针）/第一个结点

### 线性表链式存储结构代码描述

C语言中可用结构指针

```c
typeof struct Node
{
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node *LinkList; // 定义LinkList
```

结点：由存放数据元素的数据域存放后继结点地址的指针域组成。

p->data

1. 结点a(i)的数据域的表示方式
2. p是指向线性表第i个元素的指针；（可以表示一整个结点）
3. p->data的值：一个数据元素；

p->next

1. 结点a(i)的指针域的表示方式；
2. p->next的值：一个指针，指向a(i+1)的指针

所以，如果p->data=a(i)，那么p->next->data = a(i+1)；

## 单链表的读取

获取链表第i个数据的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 到链表末尾p为空，则说明第i个元素不存在；
4. 否则查找成功，则返回结点p的数据；

时间复杂度为O(n)

注意：由于单链表结构没有定义表长，所以不知道循环次数，因此不用for。核心思想：工作指针后移。

```c
// 初始条件：顺序线性表L已存在
// 用e返回L中第i个数据元素的值
Status GetElem(LinkList L, int i, ElemType *e) 
{
    int j;
    LinkList p; // 声明结点p
    p = L->next; // p指向链表L的第一个结点
    j = 1; // j为计数器
    while (p && j < i)  // p不为空或者计数器j还未等于i时
    {
        p = p -> next;
        ++j;
    }
    if (!p || j >i) return ERROR;
    *e = p->data;
    return OK;
}
```

## 单链表的插入与删除

### 单链表的插入

结点s插入结点p和p->next

方法：s->next = p->next;  p->next = s;

注意：两个步骤不能相反；

单链表第i个数据插入结点的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 到链表末尾p为空，则说明第i个元素不存在；
4. 否则查找成功，在系统中生成一个空结点s；
5. 将数据元素e赋值给s->data‘
6. 实施下列操作：s->next = p->next;  p->next = s;
7. 返回成功；

```c
// 初始条件：顺序线性表L已存在
// 在L中第i个位置之前插入新的数据元素e，L的长度加1
Status GetElem(LinkList *L, int i, ElemType e) 
{
    int j;
    LinkList p,s;
    p = *L; 
    j = 1;
    while (p && j < i)  // 寻找第i个结点
    {
        p = p -> next;
        ++j;
    }
    if (!p || j >i) return ERROR;
    s = (LinkList)malloc(sizeof(Node));//生成新结点
    s->data = e;
    s->next = p->next; //将p的后继结点赋值给s的后继
    p->next = s; // 将s赋值给p的后继
    return OK;
}
// malloc标准函数作用：生成一个新的结点（实质是在内存中找了块小空地，存放e数据s结点）
```

### 单链表的删除

设存储元素a(i)的结点为q，实现删除q的操作

方法：p->next = p->next->next(也就是q = p->next,  p->next = q->next)

单链表第i个数据删除结点的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 到链表末尾p为空，则说明第i个元素不存在；
4. 否则查找成功，将欲删除的结点p->next赋值给q；
5.  p->next = q->next
6. 将q结点中的数据赋值给e，作为返回；
7. 释放q结点；
8. 返回成功

```c
// 初始条件：顺序线性表L已存在
// 删除L中的第i个数据元素，并用e返回其值，L的长度减1
Status GetElem(LinkList *L, int i, ElemType e) 
{
    int j;
    LinkList p,s;
    p = *L; 
    j = 1;
    while (p && j < i)  // 寻找第i个结点
    {
        p = p -> next;
        ++j;
    }
    if (!p || j >i) return ERROR;
    q = p->next;
    p->next = q->next;
    *e = q->data; // 将q结点中的数据给e*
    free(q); // 让系统回收此结点，释放内存
    return OK;
}
// free标准函数作用：让系统回收一个Node结点，释放内存；
```

### 总结

插入和删除都由两部分组成：遍历查找第i个元素；插入和删除元素；

时间复杂度：O(n)

如果不知道第i个元素的指针位置，关于插入和删除操作，线性表顺序和单链表都大同小异；

但是从第i个位置插入10元素，线性顺序每次插入都是O(n)，单链表是第一次O(n)，后面都是O(n)

因此，单链表适合频繁插入或删除数据的频繁操作；

## 单链表的整表创建

顺序存储结构：数组初始化，即声明一个类型和大小的数组并赋值的过程；

单链表：动态结构；所占用空间的大小和位置不需要预先分配划定；

创建单链表的过程=动态生成链表，即从“空表”初始状态，依次建立结点，逐个插入链表。

单链表整表创建的算法思路：

1. 声明一结点p和计数变量i；
2. 初始化一空链表L；
3. 让L的头结点的指针指向null，即建立一个带头结点的单链表；
4. 循环：
   - 生成一新结点赋值给p；
   - 随机生成一数字赋值给p的数据域p->data;
   - 将p插入到头结点与前一新结点之间；

```c
//随机产生n个元素的值，建立带表头结点的单链线性表L（头插法）
void CreateListHead(LinkList *L, int n) 
{
    LinkList p;
    int i;
    srand (time(0)); // 初始化随机数种子
    *L = (LinkList)malloc(sizeof(Node));
    (*L)->next = null; // 建立一个带头结点的单链表
    for (i = 0; i < n; i++) 
    {
        p = (LinkList)maloc(sizeof(Node)); // 生成新结点
        p->data = rand( )%100 + 1; // 随机生成100以内的数字
        p->next = (*L)->next;
        (*L)->next = p;// 插到表头
    }
}
// 头插法：始终让新结点再第一位
```

```c
// 尾插法：新结点插在终端结点后面
void CreateListHead(LinkList *L, int n) 
{
    LinkList p,r;
    int i;
    srand (time(0)); // 初始化随机数种子
    *L = (LinkList)malloc(sizeof(Node));
    r = *L; // r指向尾部的结点
    for (i = 0; i < n; i++) 
    {
        p = (Node *)maloc(sizeof(Node)); // 生成新结点
        p->data = rand( )%100 + 1; // 随机生成100以内的数字
        r->next = p; //将当前新结点定义为表尾终端结点
        r = p;// 将当前的新结点定义为表尾终端结点
    }
    r->next = NULL; // 表示当前链表结束
}
```

## 单链表的整表删除

销毁，留出空间

**单链表整表删除的算法思路**：

1. 声明一结点赋值给q；
2. 将第一个结点赋值给p；
3. 循环：
   - 将下一个结点赋值给q；
   - 释放p；
   - 将q赋值给p；

注意：q在其中的作用是记录下一个结点；

```c
// 顺序线性表L已存在；操作结果：将L重置为空表
Status ClearList(LinkList *L)
{
    LinkList p,q;
    p=(*L)->next; // p指向第一个结点
    while(p) //循环到表尾
    {
        q = p->next;
        free(p);
        p = q;
    }
    (*L)->next = NULL; //头结点指针域为空
    return OK;
}
```

## 单链表结构与顺序存储结构优缺点

1. 存储分配方式：
   - 顺序：一段连续存储线性表的数据元素
   - 单链表：链式存储结构（用一组任意的存储单元存放线性表的元素）

2. 时间性能：
   - 查找
     - 顺序：O(1)
     - 单链表：O(n)
   - 插入和删除
     - 顺序：O(n)
     - 单链表：O(1)

3. 空间性能：
   - 顺序：预分配存储空间，容易浪费或上溢
   - 单链表：不限制，不预分配

## 静态链表

也叫游标实现法

数组中的元素由两个数据域组成（data和cur）。

- 数据域data用于存放数据元素；游标cur相当于next指针，存放该元素的后继在数组中的下标；（有点类似于数组每一项是个object，有两个属性，一个是存放数据域，一个存放后继元素下标）
- 第一个和最后一个元素特殊处理
  - 第一个元素（下标为0的元素的cur）存放**备用链表**的第一个结点的下标；
  - 最后一个元素cur存放第一个有数值的元素的下标=头结点的作用
  - 链表为空时为0²
- 未被使用的数组元素称为备用链表
- 具体可见73页 图3-12-2

### 静态链表的插入操作

静态模拟动态链表结构的存储空间，需要时申请，无用时释放

数组中没有结点申请和释放的问题，因此需要自己实现函数

```c
// 类似于结点申请的函数malloc()
int Malloc_SLL(StataicLinkList space)
{
    int i = space[0].cur; 
    if (space[0].cur)
        space[0].cur = space[i].cur;
    return i;
}
// 插入
Status ListInsert(StaticLinkList L, int i, ElemType e)
{
    int j, k, l;
    k = MAX_SIZE - 1;
    if (i < 1 || i > ListLength(L) + 1)
        return ERROR;
    j = Malloc_SSL(L); // 获得空闲的下标
    if (j)
    {
        L[j].data = e; // 将数组赋值给此分量的data
        for(l = 1; l <= i - 1; l++) // 找到第i个元素之前的位置
            k = L[k].cur;
        L[j].cur = L[k].cur; //把第i个元素之前的cur赋值给新元素的cur
        L[k].cur = j; // 把新元素的下标赋值给第i个元素之前元素的cur
        return OK;
    }
    return ERROR;
}
```

### 静态链表的删除操作

```c
// 类似于free()函数
void Free_SSL(StaticLinkList space, int k)
{
    space[k].cur = space[0].cur; // 把第一个元素cur（空闲下标）赋值给将要删除的分量cur中
    space[0].cur = k; // 将删除的分量下标给第一个元素的cur
}

Status ListDelete(StaticLinkList L, int i)
{
    int j, k;
    if (i < 1 || i > ListLength(L))
        return ERROR;
    k = MAX_SIZE - 1;
    for (j = 1; j <= i -1; j++)
        k = L[k].cur; // 寻找到i之前的位置
    j = L[k].cur; // 获取i位置
    L[k].cur = L[j].cur; //i-1的cur指向i+1
    Free_SSL(L, j);// 释放
    return OK;
}
```

### 优缺点

优点：只需要改动游标，不需要移动元素；

缺点：表长问题；失去了顺序存储结构随机存取的特性；

## 循环链表

定义：将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环。这种头尾相接的单链表称为单循环链表（循环链表）。

PS.为了空链表和非空链表一致，通常会设置一个头结点。

尾指针：可以达到用O(1)的时间访问最后一个结点；

