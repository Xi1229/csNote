# 数据结构绪论



数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及他们之间的关系和操作等相关问题的学科。

## 基本概念和术语

### 数据

概念：数据是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并**输入给计算机处理**的符号集合。

数据=符号，但是需具备两个前提：可以输入到计算机中；能被计算机处理。

类型：数值类型（整型、实型等）【可计算数值】、非数值类型（字符、声音、图像、视频等）【通过编码的手段变成字符数据】。

### 数据元素

概念：数据元素是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也称为记录。

数据元素是数据结构中建立数据模型的着眼点。

### 数据项

概念：一个数据元素可以由若干数据项组成。数据项是数据不可分割的最小单位。

### 数据对象

概念：数据对象是性质相同的数据元素的集合，是数据的子集。

### 数据结构

数据元素存在特定关系。这种关系称为结构。

概念：数据结构是相互之间存在一种或多种和特定关系的数据元素的集合。



## 逻辑结构与物理结构

### 逻辑结构

概念：数据对象中数据元素之间的相互关系。

#### 集合结构

类似于数学中的集合，同属于一个集合，数据元素之间是平等的。

#### 线性结构

一对一，连成一条线。

#### 树形结构

一对多的层次关系

#### 图形结构

多对多的关系，像关系网

ps.关系可能是有方向的。

### 物理结构

概念：物理结构是数据的逻辑结构在计算机中的存储形式。

也就是把数据元素存储到计算机的存储器中。同时，数据的存储结构应该正确反映数据元素之间的逻辑关系。

存储形式：顺序存储和链式存储。

#### 顺序存储结构

概念：顺序存储结构是把数据元素放在地址连续的存储单位里，其数据间逻辑关系和物理关系一致。

#### 链式存储结构

概念：链式存储结构是把数据元素存放在任意存储单元里，这组存储单元可以是连续的，也可以是不连续的。

数据元素的存储关系并不能反映其逻辑关系，需要用一个指针存放数据元素的地址。可以通过地址找到相关联数据元素的位置。



## 抽象数据类型

### 数据类型

概念：数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作总称。

数据类型是按照值得不同进行划分的。在高级语言中，每个变量、常量和表达式都有各自的取值范围。类型就用来说明变量或表达式的取值范围和所能进行的操作。

如c语言中变量声明int a, b。在给变量a和b赋值时不能超出int的取值范围，变量a和b之间的运算只能是int类型所允许的运算。

### 抽象数据类型

概念：抽象数据类型是指一个数学模型及定义在该模型上的一组操作。

抽象数据类型的定义仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。

可以是已定义并实现的数据类型，也可是自己定义的数据类型。

抽象数据类型体现了程序设计中问题分解、抽象和信息隐藏的特性。

过程：问题分解成多个规模小且容易处理的问题，然后建立一个计算机能处理的数据模型，并把每个功能模块的实现细节作为一个独立的单元，从而使具体实现过程隐藏起来。



# 算法

## 算法的定义

算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

为了解决某个或某类问题，需要把指令表示成一定的操作序列。操作序列包括一组操作。每个操作都完成特定的功能——算法

## 算法的特性

基本特性（5）：输入、输出、有穷性、确定性和可行性；

### 输入输出

算法输入>=0，一般情况下，输入参数是必要的；

算法输出>=1

### 有穷性

有穷性是指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每个步骤在可接受的时间内完成；

不是数学上的概念，而是需要有一个合理的边界；

### 确定性

确定性指算法的每一步骤都具有确定的含义，不会出现二义性；

一条执行路径（相同的输入只能有唯一的输出结果）；算法每个步骤都被精确定义而无歧义；

### 可行性

可行性指算法的每一步都必须可行，也就是说，每一步都能够通过执行有限次数完成。

可以转换为程序上机运行，并得到正确的结果。

## 算法设计的要求

### 正确性

概念：算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需求、能够得到问题的正确答案。

4个层次（从易到难）：

1. 算法程序没有语法错误；
2. 算法程序对于合法的输入数据能够产生满足要求的输出结果；
3. 算法程序对于非法的输入数据能够得出满足规格说明的结果；
4. 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果；

层次4最困难，几乎不可能验证；因此，一般以3作为算法是否正确的标准；

### 可读性

概念：算法设计的另一目的是为了便于阅读、理解和交流；

### 健壮性

概念：当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果。

### 时间效率高和存储量低

概念：

1. 时间效率：算法的执行时间
2. 存储量需求：算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间

## 算法效率的度量方法

### 事后统计方法

概念：主要通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低。

很大的缺陷：耗时耗力；时间的比较依赖计算机硬件和软件等环境因素；测试数据设计困难，且程序运行时间和测试数据的规模有很大关系；

基本不采纳

### 事前分析估算方法

1. 概念：在计算机程序编制前，依据统计方法对算法进行估算；

2. 决定消耗时间的因素：

1. 算法采用的策略、方法；（算法好坏根本）
2. 编译产生的代码质量；（软件）
3. 问题的输入规模；（输入量）
4. 机器执行指令的速度；（硬件性能）

主要依赖于算法好坏和问题输入规模

3. 测定运行时间最可靠的方法

计算对运行时间有消耗的基本操作的执行次数（和运行时间成正比），即将程序看作是独立于程序设计语言的算法或一系列步骤；

分析时，把基本操作的数量与输入规模关联起来，即基本操作的数量必须表示成输入规模的函数 =》f(n) = n  f(n) = 1

主要通过算法时间复杂度来估算时间效率

## 函数的渐近增长

概念：给定两个函数f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N，f(n)总比g(n)大，那么，我们说f(n)的增长渐近快于g(n)。

结论：判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数；

## 算法时间复杂度

### 定义

在进行算法分析时， 语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n) 的数量级。

算法的时间复杂度，也就是算法的时间量度，记作：T(n) = O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。

O(1)=》常数阶   O(n)=》线性阶  O(n²) =》平方阶

### 推导大O阶方法

总结来说就是常数改成1，再取最高阶项

### 常数阶

O(1)：与问题的大小无关（即n的大小），执行时间恒定的算法

### 线性阶

O(n)

关键：分析循环结构的运行情况

### 对数阶

O(logn)

```
init count = 1;
while (count < n) {
	count = count * 2;
}
```

### 平方阶

O(n²)

主要是考察数列的相关运算

## 常见的时间复杂度

O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2的指数)<O(n!)<O(n的指数)

## 最坏情况与平均情况

最坏情况：是一种保证。除非特别指定，提到的运行时间都是最坏的运行时间。

平均情况：平均运行时间是期望是运行时间；

## 算法空间复杂度

概念：算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所存储空间的函数。

相关因素：程序本身的指令、常数、变量和输入数据、对数据操作的存储单元；

# 线性表

## 线性表的定义

线性表（List）：零个或多个数据元素的**有限**序列。

- 序列意味着元素之间有顺序；第一个元素无前驱，最后一个无后继，其他每个元素都有且只有一个前驱和后继。

- 线性表的个数n（n>=0）定义为线性表的长度，当n=0时，称为空表。

- 在较复杂的线性表中，一个数据元素可以由若干个数据项组成。


PS.线性表需要相同类型的数据。

## 线性表的抽象数据类型

线性表的操作：重置为空表，根据位序获取数据元素，查找元素，获取线性表长度，插入数据和删除数据；

线性表的抽象数据类型定义：

```
ADT 线性表
Data 
	线性表的数据对象集合为{a1, a2,..., an}，每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an之外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。
operation
	初始化
	判断是否为空
	线性表清空
	根据位序获取数据元素
	查找元素
	获取线性表长度
	插入数据
	删除数据
endADT
```

## 线性表的顺序存储结构

### 顺序存储定义

指的是用一段地址连续的存储单元依次存储线性表（通常用数组实现）

### 顺序存储方式

类似于一维数组（将第一个数据元素存在数组下标为0的位置，再把线性表相邻的元素存储在数组中相邻的位置。

描述顺序存储结构需要三个属性：

- 存储空间的起始位置：数组data，其存储位置就是存储空间的存储位置
- 线性表的最大存储容量：数组长度MaxSize；
- 线性表的当前长度：length；

### 数据长度与线性表长度区别

数组长度：存放线性表的存储空间的长度，存储分配后这个量是不变的；

线性表长度：线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。

线性表长度<=数组长度

### 地址计算方法

下标从0开始；第i个元素下标i-1的位置；

地址：存储器中的每个存储单元的编号；

线性表中的数据元素的存储位置之间的关系：

```
LOC(a(i+1)) = LOC(a(i)) + c   第i+1个数据元素存储位置和第i个数据元素的存储位置
LOC(a(i)) = LOC(a(1)) + (i-1)*c  第i个数据元素a(i)的存储位置与a(1)之间的关系
LOC表示获得存储位置的函数
```

随机存取结构：通过上面的公式，可随时算出线性表中任意位置的地址，可任意存入或取出。存取时间性能为O(1)。

## 顺序存储结构的插入与删除

### 获得元素操作

返回对应下标的值

### 插入操作

插入算法的思路：

- 插入位置不合理，则抛出异常；
- 线性表长度>=数组长度，则抛出异常或动态增加容量；
- 从最后一个元素开始向前遍历到第i个元素，分别将它们都向后移动一个位置；
- 将要插入的元素填入位置i处；
- 表长加1；

### 删除操作

删除算法的思路：

- 删除位置不合理，则抛出异常；
- 取出删除元素；
- 从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前移动一个位置；
- 表长减1；

线性表的顺序存储结构：

在存、读数据时，时间复杂度为O(1)；在插入或删除时，时间复杂度是O(n)；

因此，适合元素个数不太变化，经常存取数据的情况。

### 线性表顺序存储结构的优缺点

优点：无须为表示表中元素之间的逻辑关系而增加额外的存储空间；可快速存取表中任一位置的元素；

缺点：插入和删除操作需要移动大量元素；当线性表长度变化较大时，难以确定存储空间的容量；造成存储空间的碎片；

## 线性表的链式存储结构

### 定义

数据元素既要存储本身信息，又要存储指示其直接后继的信息（即直接后继的存储位置）。

数据域：存储数据元素信息的域；

指针域：存储直接后继位置的域；存储的信息称作**指针**或**链**；

结点：数据域和指针域组成数据元素ai的**存储映像**。

概念：n个节点（ai的存储映像）链结成一个链表，即为线性表的链式存储结构。同时，此链表的每个节点只包含了一个指针域，所以叫单链表。

链表中的第一个节点的存储位置叫做头指针（指向第一个结点）；最后一个结点指针为空；

头节点：有时，为了方便操作，向单链表的第一个结点前附设的一个节点。可不存储任何信息；也可存储如线性表的长度等附加信息。指针域指向第一个节点的指针。

### 头指针和头结点的异同

头指针：

- 指链表指向第一个结点的指针；若链表有头结点，则是指向头结点的指针；
- 具有标识作用，因此常用头指针冠以链表的名字；
- 头指针是链表的必要元素。无论链表是否为空，头指针均不为空；

头结点：

- 为了方便而设立，放在第一元素的结点之前，其数据域一般无意义或存放链表长度；
- 第一元素结点前插入结点和删除第一结点的操作与其他结点一致；
- 不是链表必要元素；

头指针 =》头结点（空数据域+指向第一个结点的指针）/第一个结点

### 线性表链式存储结构代码描述

C语言中可用结构指针

```c
typeof struct Node
{
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node *LinkList; // 定义LinkList
```

结点：由存放数据元素的数据域存放后继结点地址的指针域组成。

p->data

1. 结点a(i)的数据域的表示方式
2. p是指向线性表第i个元素的指针；（可以表示一整个结点）
3. p->data的值：一个数据元素；

p->next

1. 结点a(i)的指针域的表示方式；
2. p->next的值：一个指针，指向a(i+1)的指针

所以，如果p->data=a(i)，那么p->next->data = a(i+1)；

## 单链表的读取

获取链表第i个数据的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 到链表末尾p为空，则说明第i个元素不存在；
4. 否则查找成功，则返回结点p的数据；

时间复杂度为O(n)

注意：由于单链表结构没有定义表长，所以不知道循环次数，因此不用for。核心思想：工作指针后移。

```c
// 初始条件：顺序线性表L已存在
// 用e返回L中第i个数据元素的值
Status GetElem(LinkList L, int i, ElemType *e) 
{
    int j;
    LinkList p; // 声明结点p
    p = L->next; // p指向链表L的第一个结点
    j = 1; // j为计数器
    while (p && j < i)  // p不为空或者计数器j还未等于i时
    {
        p = p -> next;
        ++j;
    }
    if (!p || j >i) return ERROR;
    *e = p->data;
    return OK;
}
```

## 单链表的插入与删除

### 单链表的插入

结点s插入结点p和p->next

方法：s->next = p->next;  p->next = s;

注意：两个步骤不能相反；

单链表第i个数据插入结点的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 到链表末尾p为空，则说明第i个元素不存在；
4. 否则查找成功，在系统中生成一个空结点s；
5. 将数据元素e赋值给s->data‘
6. 实施下列操作：s->next = p->next;  p->next = s;
7. 返回成功；

```c
// 初始条件：顺序线性表L已存在
// 在L中第i个位置之前插入新的数据元素e，L的长度加1
Status GetElem(LinkList *L, int i, ElemType e) 
{
    int j;
    LinkList p,s;
    p = *L; 
    j = 1;
    while (p && j < i)  // 寻找第i个结点
    {
        p = p -> next;
        ++j;
    }
    if (!p || j >i) return ERROR;
    s = (LinkList)malloc(sizeof(Node));//生成新结点
    s->data = e;
    s->next = p->next; //将p的后继结点赋值给s的后继
    p->next = s; // 将s赋值给p的后继
    return OK;
}
// malloc标准函数作用：生成一个新的结点（实质是在内存中找了块小空地，存放e数据s结点）
```

### 单链表的删除

设存储元素a(i)的结点为q，实现删除q的操作

方法：p->next = p->next->next(也就是q = p->next,  p->next = q->next)

单链表第i个数据删除结点的算法思路：

1. 声明一个结点p指向链表第一个结点，初始化j从1开始；
2. 当j<i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；
3. 到链表末尾p为空，则说明第i个元素不存在；
4. 否则查找成功，将欲删除的结点p->next赋值给q；
5.  p->next = q->next
6. 将q结点中的数据赋值给e，作为返回；
7. 释放q结点；
8. 返回成功

```c
// 初始条件：顺序线性表L已存在
// 删除L中的第i个数据元素，并用e返回其值，L的长度减1
Status GetElem(LinkList *L, int i, ElemType e) 
{
    int j;
    LinkList p,s;
    p = *L; 
    j = 1;
    while (p && j < i)  // 寻找第i个结点
    {
        p = p -> next;
        ++j;
    }
    if (!p || j >i) return ERROR;
    q = p->next;
    p->next = q->next;
    *e = q->data; // 将q结点中的数据给e*
    free(q); // 让系统回收此结点，释放内存
    return OK;
}
// free标准函数作用：让系统回收一个Node结点，释放内存；
```

### 总结

插入和删除都由两部分组成：遍历查找第i个元素；插入和删除元素；

时间复杂度：O(n)

如果不知道第i个元素的指针位置，关于插入和删除操作，线性表顺序和单链表都大同小异；

但是从第i个位置插入10元素，线性顺序每次插入都是O(n)，单链表是第一次O(n)，后面都是O(n)

因此，单链表适合频繁插入或删除数据的频繁操作；

## 单链表的整表创建

顺序存储结构：数组初始化，即声明一个类型和大小的数组并赋值的过程；

单链表：动态结构；所占用空间的大小和位置不需要预先分配划定；

创建单链表的过程=动态生成链表，即从“空表”初始状态，依次建立结点，逐个插入链表。

单链表整表创建的算法思路：

1. 声明一结点p和计数变量i；
2. 初始化一空链表L；
3. 让L的头结点的指针指向null，即建立一个带头结点的单链表；
4. 循环：
   - 生成一新结点赋值给p；
   - 随机生成一数字赋值给p的数据域p->data;
   - 将p插入到头结点与前一新结点之间；

```c
//随机产生n个元素的值，建立带表头结点的单链线性表L（头插法）
void CreateListHead(LinkList *L, int n) 
{
    LinkList p;
    int i;
    srand (time(0)); // 初始化随机数种子
    *L = (LinkList)malloc(sizeof(Node));
    (*L)->next = null; // 建立一个带头结点的单链表
    for (i = 0; i < n; i++) 
    {
        p = (LinkList)maloc(sizeof(Node)); // 生成新结点
        p->data = rand( )%100 + 1; // 随机生成100以内的数字
        p->next = (*L)->next;
        (*L)->next = p;// 插到表头
    }
}
// 头插法：始终让新结点再第一位
```

```c
// 尾插法：新结点插在终端结点后面
void CreateListHead(LinkList *L, int n) 
{
    LinkList p,r;
    int i;
    srand (time(0)); // 初始化随机数种子
    *L = (LinkList)malloc(sizeof(Node));
    r = *L; // r指向尾部的结点
    for (i = 0; i < n; i++) 
    {
        p = (Node *)maloc(sizeof(Node)); // 生成新结点
        p->data = rand( )%100 + 1; // 随机生成100以内的数字
        r->next = p; //将当前新结点定义为表尾终端结点
        r = p;// 将当前的新结点定义为表尾终端结点
    }
    r->next = NULL; // 表示当前链表结束
}
```

## 单链表的整表删除

销毁，留出空间

**单链表整表删除的算法思路**：

1. 声明一结点赋值给q；
2. 将第一个结点赋值给p；
3. 循环：
   - 将下一个结点赋值给q；
   - 释放p；
   - 将q赋值给p；

注意：q在其中的作用是记录下一个结点；

```c
// 顺序线性表L已存在；操作结果：将L重置为空表
Status ClearList(LinkList *L)
{
    LinkList p,q;
    p=(*L)->next; // p指向第一个结点
    while(p) //循环到表尾
    {
        q = p->next;
        free(p);
        p = q;
    }
    (*L)->next = NULL; //头结点指针域为空
    return OK;
}
```

## 单链表结构与顺序存储结构优缺点

1. 存储分配方式：
   - 顺序：一段连续存储线性表的数据元素
   - 单链表：链式存储结构（用一组任意的存储单元存放线性表的元素）

2. 时间性能：
   - 查找
     - 顺序：O(1)
     - 单链表：O(n)
   - 插入和删除
     - 顺序：O(n)
     - 单链表：O(1)

3. 空间性能：
   - 顺序：预分配存储空间，容易浪费或上溢
   - 单链表：不限制，不预分配

## 静态链表

也叫游标实现法

数组中的元素由两个数据域组成（data和cur）。

- 数据域data用于存放数据元素；游标cur相当于next指针，存放该元素的后继在数组中的下标；（有点类似于数组每一项是个object，有两个属性，一个是存放数据域，一个存放后继元素下标）
- 第一个和最后一个元素特殊处理
  - 第一个元素（下标为0的元素的cur）存放**备用链表**的第一个结点的下标；
  - 最后一个元素cur存放第一个有数值的元素的下标=头结点的作用
  - 链表为空时为0²
- 未被使用的数组元素称为备用链表
- 具体可见73页 图3-12-2

### 静态链表的插入操作

静态模拟动态链表结构的存储空间，需要时申请，无用时释放

数组中没有结点申请和释放的问题，因此需要自己实现函数

```c
// 类似于结点申请的函数malloc()
int Malloc_SLL(StataicLinkList space)
{
    int i = space[0].cur; 
    if (space[0].cur)
        space[0].cur = space[i].cur;
    return i;
}
// 插入
Status ListInsert(StaticLinkList L, int i, ElemType e)
{
    int j, k, l;
    k = MAX_SIZE - 1;
    if (i < 1 || i > ListLength(L) + 1)
        return ERROR;
    j = Malloc_SSL(L); // 获得空闲的下标
    if (j)
    {
        L[j].data = e; // 将数组赋值给此分量的data
        for(l = 1; l <= i - 1; l++) // 找到第i个元素之前的位置
            k = L[k].cur;
        L[j].cur = L[k].cur; //把第i个元素之前的cur赋值给新元素的cur
        L[k].cur = j; // 把新元素的下标赋值给第i个元素之前元素的cur
        return OK;
    }
    return ERROR;
}
```

### 静态链表的删除操作

```c
// 类似于free()函数
void Free_SSL(StaticLinkList space, int k)
{
    space[k].cur = space[0].cur; // 把第一个元素cur（空闲下标）赋值给将要删除的分量cur中
    space[0].cur = k; // 将删除的分量下标给第一个元素的cur
}

Status ListDelete(StaticLinkList L, int i)
{
    int j, k;
    if (i < 1 || i > ListLength(L))
        return ERROR;
    k = MAX_SIZE - 1;
    for (j = 1; j <= i -1; j++)
        k = L[k].cur; // 寻找到i之前的位置
    j = L[k].cur; // 获取i位置
    L[k].cur = L[j].cur; //i-1的cur指向i+1
    Free_SSL(L, j);// 释放
    return OK;
}
```

### 优缺点

优点：只需要改动游标，不需要移动元素；

缺点：表长问题；失去了顺序存储结构随机存取的特性；

## 循环链表

定义：将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环。这种头尾相接的单链表称为单循环链表（循环链表circular linked list）。

PS.为了空链表和非空链表一致，通常会设置一个头结点。

尾指针：可以达到用O(1)的时间访问最后一个结点以及第一个结点；也方便合并；具体见80页

## 双向链表

定义：双向链表（double linked list）是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。

作用：方便查找上一个结点；

```c
// 线性表的双向链表存储结构
typeof struct DulNode
{
    ElemType data;
    struct DulNode *prior; // 直接前驱指针
    struct DulNode *next; // 直接后继指针
} DulNode, *DuLinkList
```

双向链表也可是循环表， 具体见82页；

双向链表由单链表扩展而出，因此操作很多都相同；

虽然方便反向查询，但是插入和删除需要更改两个指针变量；（注意操作顺序）

```c
// 将结点s插入到结点p和p->next
s->prior = p;
s->next = p->next;
p->next->prior = s;
p->next = s;
// 删除结点p
p->prior->next = p->next;
p->next->prior = p->prior;
free(p)
```

总结：用空间换时间；

# 栈与队列

## 栈的定义

### 定义

栈（stack）是限定仅在表尾进行插入和删除操作的线性表。也称为后进先出（Last In First Out）的线性表（简称LIFO结构）。

- 栈顶（top）：允许插入和删除的一端；
- 栈底（bottom）
- 空栈：不包含任何数据元素的栈；

注意：

- 栈元素具有线性关系（前驱后继关系）
- 是一种特殊线性表，在表尾（栈顶）插入和删除；
- 限制插入和删除的位置；

栈的插入操作：进栈（压栈、入栈）；

栈的删除操作：出栈（弹栈）；

### 进栈出栈变化形式

最先进栈的元素不一定最后出栈；

原因：栈只是对线性表的插入和删除的位置进行了限制，并未对元素进出事件进行限制。

## 栈的抽象数据类型

具备线性表的操作，有些许区别

```c
ADT 栈（stack）
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继的关系。
Operation
    InitStack(*S)：初始化操作
    DestroyStack(*S)： 若栈存在，则销毁它
    ClearStack(*S)：将栈清空
    StackEmpty(S)：若栈为空，返回true，否则返回false
    GetTop(S, *e)：若栈存在且非空，用e返回S的栈顶元素
    Push(*S, e)：若栈S存在，插入新元素e到栈S中并成为栈顶元素
    Pop(*S, e)：删除栈S中栈顶元素，并用e返回其值
    StackLength(S)：返回栈S的元素个数
endADT
```

## 栈的顺序存储结构及实现

### 栈的顺序存储结构

```c
typeof int SElemType; //类型根据实际情况而定
typeof struct
{
    SElemType data[MAXSIZE];
    int top; // 用于栈顶指针
}SqStack;
//top< StackSize;当栈存在一个元素时，top=0；空栈判定条件：top=-1；
```

### 栈的顺序存储结构——进栈操作

```c
// 插入元素e，即push操作
Status Push (SqStack *S, SElemType e)
{
    if (S->top == MAXSIZE - 1) // 栈满
    {
        return ERROR;
    }
    S->top++; //指针加一
    S->data[S->top] = e; // 将新插入怨怒是赋值给栈顶空间
    return OK;
}
// 时间复杂度 O(1)
```

### 栈的顺序存储结构——出栈操作

```c
// 若栈不空，删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR
// 出栈pop操作
Status Pop (SqStack *S, SElemType *e)
{
    if (S->top == -1)
        return ERROR;
    *e = S->data[S->top]; //将要删除的栈顶元素赋值给e
    S->top--; //栈顶指针减一
    return OK;
}
// 时间复杂度 O(1)
```

## 两栈共享空间

思路：top1为栈1的栈顶指针；top2为栈2的栈顶指针；top1和top2分别在数组的两端；

```c
// 空间结构
typeof struct
{
    SElemType data[MAXSIZE];
    init top1;
    init top2;
}SqDoubleStack;
// push e为新栈顶元素
// stackNumber为栈号参数
Status Push(SqDoubleStack *S, SElemType e, int stackNumber)
{
    if(S->top+1 == S->top2) // 栈已满，不能再push
        return ERROR;
    if(stackNumber == 1) // 栈1有元素进栈
        S->data[++S->top1] = e; 
    else if (stackNumber == 2) // 栈2元素进栈
        S->data[--S->top2] = e;
    return OK;
}
// pop S的栈顶元素，用e返回值
Status Pop(SqDoubleStack *S, SElemType *e, int stackNumber)
{
    if (stackNumber == 1)
    {
        if (S->top1==-1)
            return ERROR;
        *e = S->data[S->top1--]； // 出栈操作
    }
    else if (stackNumber == 2)
    {
        if (S->top2 == MAXSIZE)
            return ERROR;
        *e = S->data[S->top2++]; // 出栈操作
    }
    return OK;
}
```

使用场景：两个栈的空间需求有相反关系时，即一个栈增长时另一个栈在缩短的情况（注意两个栈的数据类型需相同）

## 栈的链式存储结构及实现

### 栈的链式存储结构

简称**链栈**

- 头指针=栈顶指针，通常不需要头结点
- 不存在栈满的情况
- 空栈，top=NULL

```c
// 链栈结构
typedef struct StackNode
{
    SElemType data; // 数据域，保存栈的元素
    struct StackNode *next; // 指向下一个节点的指针
}StackNode, *LinkStackPtr; // 为这个结构体定义了两种类型：StackNode 和指向它的指针类型 LinkStackPtr

typedef struct LinkStack
{
    LinkStackPtr top; // 指向栈顶的指针
    int count; // 记录栈中的元素数量
}LinkStack; // 为这个结构体类型定义了一个别名 LinkStack
```

### 栈的链式存储结构——进栈操作

```c
// 插入元素e为新栈顶元素
Status Push(LinkStack *S, SElemType e)
{
    LinkStackPtr s = (LinkStackPtr)malloc(sizeof (StackNode));
    s->data = e;
    s->next = S->top; // 把当前的栈顶元素赋值给新结点的直接后继；
    S->top = s; // 将新结点s赋值给栈顶指针
    S->count++;
    return OK
}
// 时间复杂度O(1)
```

### 栈的链式存储结构——出栈操作

```c
// 将栈顶指针下移一位，最后释放出栈元素即可
// 删除栈顶元素，并用e返回其值
Status Pop(LinkStack *S, SElemType *e)
{
    LinkStackPtr p;
    if (StackEmpty(*S))
        return ERROR;
    *e = S->top->data;
    p = S->top; // 将栈顶结点赋值给p
    S->top = S->top->next; // 栈顶指针下移一位，指向后一个结点
    free(p); // 释放结点p
    S->count--;
    return OK;
}
// 时间复杂度O(1)
```

链栈和顺序栈的使用场景：

- 栈的元素变化不可预料，使用链栈；
- 变化在可控范围内，使用顺序栈；

## 栈的作用

简化程序设计的问题，划分不同关注层次；

## 栈的应用——递归

### 斐波那契数列的实现

```c
int Fbi(int i)
{
    if (i < 2)
        return i == 0 ? 0 : 1;
    return Fbi(i - 1) + Fbi(i - 2);
}
int main()
{
    int i;
    for (int i = 0; i < 40; i++)
        printf("%d", Fbi(i));
    return 0;
}
```

### 递归定义

定义：一个直接调用自己或者通过一系列的调用语句简洁地调用自己的函数。至少有一个条件在满足时，递归不再进行。

#### 递归和迭代的区别

迭代：1. 循环结构；2. 不需要反复调用函数和占用额外内存；

递归：1. 选择结构；2. 结构清晰、简洁，更易理解；3. 大量递归调用会建立函数副本，耗费大量时间和内存；

#### 递归和栈的关系

编译器使用栈实现递归。

进栈：在每层递归中的函数局部变量、参数值以及返回地址；

出栈：栈顶的局部变量、参数值和返回地址被弹出，恢复调用状态；

## 栈的应用——四则运算表达式求值

### 后缀（逆波兰）表示法定义

逆波兰（Reverse Polish Notation, RPN）：一种不需要括号的后缀表达法。所有的符号都是在要运算数字的后面出现。

### 后缀表达式计算结果

后缀表达式：9 3 1-3*+10 2 / +

规则：从左到右遍历表达式的每个数字和符号，遇到数字就进栈，遇到符号，就将处于栈顶两个数组出栈进行运算，运算结果出栈，一直到最终获得结果。

### 中缀表达式转后缀表达式

中缀表达式：9+（3-1）×3+10÷2

转化为后缀表达式的规则：从左到右遍历中缀表达式的每个数字和符号。若是数字则输出（即成为后缀表达式的一部分）；若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号（乘除优先加减）则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止

## 队列的定义

队列：一种先进先出的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。

## 队列的抽象数据类型

```c
// 类似于线性表的操作，只是插入和删除位置不同
ADT 队列
Data
    同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。
Operation
    InitQueue(*Q)：初始化操作，建立一个空队列Q
    DestroyQueue(*Q)：若队列Q存在，则销毁它
    ClearQueue(*Q)：将队列Q清空
    QueueEmpty(Q)：若队列Q为空，返回true，否则返回false
    GetHead(Q, *e)：若队列Q存在且非空，用e返回队列Q的队头元素
    EnQueue(*Q, e)：若队列Q存在，插入新元素e到队列Q中并成为队尾元素
    DeQueue(*Q, *e)：删除队列中的队头元素，并用e返回其值。
    QueueLength(Q)：返回队列Q的元素个数
endADT
```

## 循环队列

### 队列顺序存储的不足

避免当只有一个元素时，队头和队尾重合，引入两个指针（front指向队头，rear指向队尾元素的下一个位置）。front = rear时，队列为空队列。

但是当数组末尾元素被占用时，会产生数组越界的错误，现象为假溢出

### 循环队列定义

循环队列：头尾相接的顺序存储结构。

头尾相连牵扯出问题：front===rear时，如何判断队列时空的还是满的；

方法1：设置标志变量flag，空为0，满为1

方法2（以此为主）：队列满时，保留一个元素空间。队列满的条件：(rear+1)%QueueSize == front(目的就是为了整合rear与front大小为一个问题)

通用的计算队列长度公式：(rear-front+QueueSize)%QueueSize

```c
typedef int QElemType;
// 循环队列的顺序存储结构
typeof struct
{
    QElemType data[MAXSIZE];
    int front; // 头指针
    int rear; // 尾指针
}SqQueue；
// 初始化
Status IntQueue(SqQueue *Q)
{
    Q->front = 0;
    Q->rear = 0;
    return OK;
}
//求队列长度
int QueueLength(SqQueue Q)
{
    return (Q.rear - Q.front + MAXSIZE) % MAXSIZE;
}
// 入队列操作
Status EnQueue(SqQueue *Q, QElemType e)
{
    if ((Q->rear+1)%MAXSIZE == Q->front) //判断队列是否满
        return ERROR;
    Q->data[O->rear] = e; // 将元素e赋值给队尾
    Q->rear = (Q->rear+1)%MAXSIZE;//rear指针后移一位，若到最后则转到数组头部
    
    return OK;
}
// 若队列不空，则删除Q中队头元素，用e返回其值
Status DeQueue(SqQueue *Q, QElemType *e)
{
    if (Q->front == Q->rear) 
        return ERROR;
    *e = Q->data[Q->front]; // 将队头元素赋值给e
    Q->front = (Q->front+1)%MAXSIZE; //front指针向后移一位置，若到最后则转到数组头部
    
    return OK;
}
```

## 队列的链式存储结构及实现

列队的链式存储结构 = 线性表的单链表，也称链队列

```c
// 队头指针指向头结点，队尾指针指向终端结点
typedef int QElemType;

typedef struct QNode // 终点结构
{
    QElemType data;
    struct QNode *next;
}QNode, *QueuePtr;

typedef struct  // 队列的链表结构
{
	QueuePtr front, rear;   // 队头队尾指针
}LinkQueue;
```

### 入队操作

```C
Status EnQueue(LinkQueue *Q, QElemType e)
{
    QueuePtr s = (QueuePtr)malloc(sizeof(QNode));
    if(!s)
        exit (OVERFLOW);
    s->data = e;
    s->next = NULL;
    Q->rear->next = s; // 将元素e新结点s赋值给原队尾结点的后继
    Q->rear = s;  // 将当前的s设置为队尾结点，rear指向s
    return OK;
}
```

### 出队操作

```c
Status DeQueue(LinkQueue *Q, QElemType *e)
{
    QueuePtr p;
    if (Q->front == Q->rear)
        return ERROR;
    p=Q->front->next; // 暂存欲删除结点
    *e=p->data; // 赋值欲删除结点给e
    Q->front->next = p->next; // 将欲删除结点后继赋值给头结点的后继
    if(Q->rear == p) // 队头是队尾的情况
        Q->rear = Q->front;
    free(p);
    return OK;
}
```

循环队列对比链队列

1. 时间都为O(1)，但是链队列因为申请和释放结点需要时间开销，所以当出入频繁时，会多消耗时间
2. 循环队列必须有固定长度-》存储元素个数和空间浪费的问题；链队列只需要一个指针域；



# 串

## 串的定义

串（string）是由零个或多个字符组成的有限序列，又名字符串。

- 零个字符的串称为空串（null string）
- 空格串只包含空格的串；
- 子串和主串；

## 串的比较

两个串的大小判断：

1. 长度长>长度短
2. 每个字符的编码。比如‘silly’<‘stupid’。

## 串的抽象数据类型

串侧重于查找字串位置。得到指定位置子串，替换子串等操作。

```c
ADT 串(string)
Data
	串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。
Operation
	StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T。
    StrCopy(T,S):串S存在，由串S复制得串。
    Clearstring(S):串S存在，将串清空。
    StringEmpty(S):若串S为空，返回true，否则返四false。
    StrLength(S):返回串S的元素个数，即串的长度。
    StrCompare(S,T):若S>T，返回值>0，若S-T，返回0，若S<T，返回值<0。
    Concat(T，S1,S2):用返回由S1和S2联接而成的新串。
    Substring(Sub,s,pos,len):串存在，1<=poss<=Strlength(s)，且0<=len<=strLength(s)-pos+1，用Sub返回串S的第pos 个字符起长度为1en的子串。			Index(S,T,pos):串S和T存在，T是非空串，1≤pos≤StrLength(s)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos 个字符之后第一次出现的位置，否则返回0。			Replace(S,T,V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。
	StrInsert(S,pos,T):串S和T存在，1≤pos<StrLength(s)+1。在串S的第 pos 个字符之前插入串T。
	StrDelete(S,pos,len):串存在，1<pos≤StrLength(s)-len+1。
从串S中删除第pos 个字符起长度为len的子串。
endADT
```

```c
// Inde的实现过程
int Index(String S, String T, int pos)
{
    int n, m, i;
    String sub;
    if (pos > 0)
    {
        n = StrLength(S)；
        m = StrLength(T);
        i = pos;
        while (i <= n-m+1)
        {
            SubString(sub, S, i, m); // 取主串的第i个位置
            if (StrCompare(sub, T) != 0) // 匹配两个串的是否相等
                ++i;
            else
                return i;
        }
    }
    return 0;
}
```

## 串的存储结构

### 串的顺序存储结构

定义：串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般是用定长数组来定义。

由于是定长数组，有些操作会有问题（上溢、截尾），所以串的存储空间可在程序执行过程中动态分配而得。比如自由存储区（堆），在c语言中可由free()和malloc()管理。

### 串的链式存储结构

与线性表相似，但为了避免空间浪费。一个结点可存放1个及以上的字符。

存放多个字符时，最后一个结点没有被占满，可用“#”或其他非串值字符不全；

在连接串时好用，但灵活和性能不如顺序存储。

## KMP模式匹配算法

可以配合代码随想录（字符串——实现strStr()）

### KMP模式匹配算法实现

```c
// 返回next数组
void get_next(String T, int *next)
{
    int i,j;
    i = 1;
    j = 0;
    next[1] = 0;
    while (i < T[0])
    {
        if (j == 0 || T[i] == T[j])
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else 
            j = next[j]
    }
}
//返回子串T在主串S中 第pos个字符之后的位置。若不存在则函数返回值为0
int Index_KMP(String S, String T, int pos)
{
    int i = pos;
    int j = 1;
    int next[255];
    get_next(T, next);
    while (i < S[0] && j <= T[0])
    {
        if (j == 0 || S[i] == T[j])
        {
            ++i;
            ++j;
        }
        else
        {
            j = next[j];
        }
    }
    if(j > T[0])
        return i - T[0];
    else
        return 0;
}
```

### KMP模式匹配算法改进

aaaabcde和aaaaax next=[0,1,2,3,4,5] =》i和j都为5时，b!=a =》j后退至next[5]，比对不相等再后退一直到j=1

```c
void get_nextval(String T, int *nextval)
{
    int i, j;
    i = 1;
    j = 0;
    nextval[1] = 0;
    while (i < T[0])
    {
        if (j == 0 || T[i] == T[j])
        {
            ++i;
            ++j;
            if (T[i] != T[j]) // 若当前字符与前缀字符不同
                nextval[i] = j; // 当前的j再nextval再i位置的值
            else
                nextval[i] = nextval[j];// 相同则将前缀字符的nextval值赋值给nextval在i位置的值
        }
        else
            j = nextval[j];
    }
}
```

# 树

## 树的存储结构

### 双亲表示法

```c
#define MAX_TREE_SIZE 100
typedef int TElemype; // 树结点的数据类型，暂定为整型
typedef struct PTNode // 终点结构
{
    TElemType data; //结点数据
    int parent; // 双亲位置
} PTNode;
typedef struct // 树结构
{
    PTNode nodes[MAX_TREE_SIZE]; // 结点数组
    int r, n; // 根的位置和结点数
}PTree;
//核心：设置指示器，指示到双亲结点到链表中位置
```

### 孩子表示法

多重链表表示法

方案一：设置固定指针域，结点数量相差大浪费空间，适合结点数量相差小的；

方案二：设置指针域总数和指针域，运算时间会有损耗（维护结点总数）

以上方案改进：

同级孩子储存为单链表，再用头指针组成线性表（采用顺序存储结构），存放进一维数组

```c
//data为数据域，firstchild是头指针域
#define MAX_TREE_SIZE 100
typedef struct CTNode // 孩子结点
{
    int child;
    struct CTNode *next;
}*ChildPtr;
typedef struct // 表头结构
{
    TElemType data;
    ChildPtr firstchild;
} CTBox;
typedef struct // 树结构
{
    CTBox nodes[MAX_TREE_SIZE]; // 结点数组
    int r, n; // 根的位置和结点数
} CTree;
// 缺点：某个结点的双亲，需要遍历  解决：将双亲和孩子表示法结合
```

#### 孩子姐妹表示法

```c
//data是数据域 firstchild存储第一个孩子结点的存储地址 rightsib存储该结点的右兄弟结点的存储地址
typedef struct CSNode
{
    TElemType data;
    struct CSNode *firstchild, *rightsib;
} CSNode, *CSTree;
// 缺陷：无法找到某个结点的双亲。 解决：增加parent指针域
// 优点：将复杂的树变为二叉树；
```

